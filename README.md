# Algorithm Practice



左神的算法课部分题目java代码自己重新实现，后期还将用c++重新实现，同时加入搜罗得到的对应LeetCode题目，持续更新...

* lecture_1包中主要内容为归并排序及其应用，除了课上实现的原始归并排序和小和问题外，增加了逆序对问题的实现
* lecture_1包中更新冒泡，插入和选择排序代码
* lecture_2包中主要内容包括荷兰国旗问题（包括l**LeetCode 75 Sort Colors**），进而引出经典快排实现，随机快排实现。同时也包括堆排实现
* lecture_3包中主要内容包括：

  - [x] MaxGap问题代码实现（**LeetCode 164 Maximum Gap**），该问题为桶排序思路的应用
  - [x] MinStack问题的代码实现（**LeetCode 155. MinStack**）
  - [x] 使用栈实现队列（**LeetCode 232. Implement Queue using Stacks**）
  - [x] 使用队列实现栈（**LeetCode 225. Implement Stack using Queues**）
* lecture_4包中主要内容包括：
  - [x] 转圈打印矩阵代码实现（**LeetCode 54. Spiral Matrix**）
  - [x] Zigzag方式打印矩阵代码实现（**LintCode 185. Matrix ZigZag Traversal**）
  - [x] 90°旋转矩阵代码实现（**LeetCode 48. Rotate Image**）
  - [x] 搜索行和列均有序的二维矩阵代码实现（**LeetCode 240. Search a 2D Matrix II**）
  - [x] 反转链表（**LeetCode 206. Reverse Linked List**）
  - [x] 判断一个链表是否为回文结构的各种代码实现（**LeetCode 234. Palindrome Linked List**）
  - [x] 将一个链表划分为左边小于某个数，右边大于等于某个数的的形式的代码实现 (**LeetCode 86. Partition List**)
  - [x] 简单无环单链表相交结点判断代码实现 (**LeetCode 160. Intersection of Two Linked Lists**) 
  - [x] 复制带有random指针的链表代码实现（**LeetCode 138. Copy List With Random Pointer**）

- lecture_5包中主要内容包括：
  - [x] 二叉树中序遍历（**LeetCode 94. Binary Tree Inorder Traversal**）、前序遍历（**LeetCode 144. Binary Tree Preorder Traversal**）、后序遍历（ **LeetCode 145, Binary Tree Postorder Traversal**）的递归版本与非递归版本实现
  - [x] 二叉树按层遍历代码实现（**LeetCode 102. Binary Tree Level Order Traversal**）
  - [x] 求二叉树最大宽度代码实现（**LeetCode 662. Maximum Width of Binary Tree**）
  - [x] 判断一颗二叉树是否为二叉搜索树的迭代实现与递归实现（树型dp）（**LeetCode 98. Validate Binary Search Tree**）
  - [x] 判断一颗二叉树是否平衡代码实现（**LeetCode 110. Balanced Binary Tree**）
  - [x] 判断一颗二叉树是否为完全二叉树（**LeetCode 958. Check Completeness of a Binary Tree**）